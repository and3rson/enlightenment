!function e(n,t,i){function r(a,s){if(!t[a]){if(!n[a]){var l="function"==typeof require&&require;if(!s&&l)return l(a,!0);if(o)return o(a,!0);var c=new Error("Cannot find module '"+a+"'");throw c.code="MODULE_NOT_FOUND",c}var u=t[a]={exports:{}};n[a][0].call(u.exports,function(e){var t=n[a][1][e];return r(t?t:e)},u,u.exports,e,n,t,i)}return t[a].exports}for(var o="function"==typeof require&&require,a=0;a<i.length;a++)r(i[a]);return r}({1:[function(e,n,t){n.exports="#define RADIUS 2.0\n#define STEP 1.0\n\nprecision mediump float;\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec2 sizePx;\n\nvoid main() {\n    vec4 color = vec4(0);\n\n    vec2 pixelSize = vec2(1.0) / sizePx.xy * 4.0;\n\n    float factorTotal = 0.0;\n\n    for (float x = -RADIUS; x <= RADIUS; x += 1.0) {\n        for (float y = -RADIUS; y <= RADIUS; y += 1.0) {\n            float factor = (RADIUS - abs(x) + 1.0) * (RADIUS - abs(y) + 1.0);\n            factorTotal += factor;\n            color += texture2D(uSampler, vTextureCoord - vec2(pixelSize.x * x * STEP, pixelSize.y * y * STEP)) * factor;\n        }\n    }\n\n    // gl_FragColor = color / pow(RADIUS * 2.0 + 1.0, 2.0);\n    gl_FragColor = color / factorTotal;\n}\n"},{}],2:[function(e,n,t){n.exports="precision mediump float;\n\n#define M_PI 3.1415926535897932384626433832795\n\nvarying vec2 vTextureCoord;\nuniform vec2 sizePx;\n\nuniform vec4 sources[1024];\nuniform int sourcesCount;\nuniform vec2 mouse;\n\nuniform vec4 faces[1024];\nuniform int facesCount;\n\nuniform vec2 cameraPos;\nuniform vec2 scaleFactor;\n\nuniform bool debug;\n\nbool ccw(in vec2 a, in vec2 b, in vec2 c) {\n    // Checks if three vectors are placed in a CCW order\n    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n}\n\nbool intersects(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    // Fast intersection check based on vertex order\n    return ccw(a, c, d) != ccw(b, c, d) && ccw(a, b, c) != ccw(a, b, d);\n}\n\nvec2 flip(in vec2 v) {\n    return vec2(v.x, 1.0 - v.y);\n}\n\nvec2 applyCameraTransformation(in vec2 point) {\n    return point - cameraPos;\n}\n\nfloat angleBetween(in float start, in float end)\n{\n    return mod(end - start, M_PI * 2.0);\n}\n\nbool isBetween(in float startAngle, in float endAngle, in float testAngle) {\n    float a1 = abs(angleBetween(startAngle, testAngle));\n    float a2 = abs(angleBetween(testAngle, endAngle));\n    float a3 = abs(angleBetween(startAngle, endAngle));\n    return (a1 + a2) - a3 < 1.0;\n}\n\nvoid main() {\n    // pixel size in units\n\n    vec2 pixelSize = vec2(1.0) / sizePx.xy;\n\n    // vec2 mousePos = mouse * pixelSize;\n\n    // Current position in pixels\n    vec2 pixelCoord = flip(vTextureCoord) / pixelSize;\n\n    // Count & total intensity of light sources that affect this point\n    vec4 lightValue = vec4(0.0);\n    float lightCount = 0.0;\n\n    // sources[0] = mouse;\n\n    for (int sourceIndex = 0; sourceIndex < 1024; sourceIndex += 3) {\n        // Loop through light sources\n        if (sourceIndex >= sourcesCount * 3) {\n            break;\n        }\n\n        for (float dx = 0.0; dx < 1.0; dx += 1.0) {\n            for (float dy = 0.0; dy < 1.0; dy += 1.0) {\n                vec4 source = vec4(sources[sourceIndex].xy + vec2(dx, dy) * 8.0, sources[sourceIndex].zw);\n                vec4 sourceColor = sources[sourceIndex + 1];\n                vec2 sourceAngle = sources[sourceIndex + 2].xy;\n\n                // Distance from current light source to current point\n                float distanceFromSource = distance(applyCameraTransformation(source.xy), pixelCoord);\n                vec2 offset = pixelCoord - applyCameraTransformation(source.xy);\n                float angleFromSource = atan(offset.y, offset.x);\n\n                if (debug) {\n                    // Draw light position & radius\n                    if (distanceFromSource < 5.0) {\n                        gl_FragColor = vec4(sourceColor.xyz, 0.1);\n                        return;\n                    }\n                    if (abs(distanceFromSource - source.z) < 5.0) {\n                        if ((sourceAngle.x == sourceAngle.y) || isBetween(sourceAngle.x, sourceAngle.y, angleFromSource)) {\n                            gl_FragColor = vec4(sourceColor.x, sourceColor.y, sourceColor.z, 0.1);\n                            return;\n                        }\n                    }\n                    // if (sourceAngle.x != sourceAngle.y) {\n                    //     if (angleFromSource - (offset.x + offset.y) / 2.0 < 2.0) {\n                    //         gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n                    //     }\n                    // }\n                }\n\n                if (distanceFromSource > source.z) {\n                    continue;\n                }\n\n                if ((sourceAngle.x != sourceAngle.y) && !isBetween(sourceAngle.x, sourceAngle.y, angleFromSource)) {\n                    continue;\n                }\n\n                // Check if segment between this point and current light source\n                // is blocked by any face\n                bool isSourceBlocked = false;\n                for (int faceIndex = 0; faceIndex < 1024; faceIndex++) {\n                    if (faceIndex >= facesCount) {\n                        break;\n                    }\n                    if (debug) {\n                        vec2 a = applyCameraTransformation(faces[faceIndex].xy);\n                        vec2 b = applyCameraTransformation(faces[faceIndex].zw);\n\n                        if (abs((distance(a, pixelCoord) + distance(b, pixelCoord)) - distance(a, b)) <= 1.0) {\n                            gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);\n                            return;\n                        }\n                    }\n                    if (intersects(applyCameraTransformation(source.xy), pixelCoord, applyCameraTransformation(faces[faceIndex].xy), applyCameraTransformation(faces[faceIndex].zw))) {\n                        // This light is blocked by one of the faces.\n                        // We don't count it.\n                        isSourceBlocked = true;\n                    }\n                }\n\n                if (!isSourceBlocked) {\n                    // Current light source affected this point, let's increase\n                    // lightValue & lightCount for this point\n                    // based on the distance from light source.\n                    // (The closer to the light source, the higher the value)\n                    float radius = source.z;\n                    float intensity = source.w;\n                    float val = max(radius - distanceFromSource, 0.0) / radius * intensity;\n                    lightValue += val * sourceColor;\n                    lightCount += 1.0;\n                    // val = max(radius - distanceFromSource, 0.0) / radius;\n                    // gl_FragColor = vec4(val, val, val, val);\n                    // return;\n                }\n            }\n        }\n    }\n\n    // lightValue /= 4.0;\n\n    // Let's cap maximum lightValue to 0.5 to prevent too much lightness\n    gl_FragColor = vec4(min(lightValue.x, 0.75), min(lightValue.y, 0.75), min(lightValue.z, 0.75), min(lightValue.w, 0.75));\n\n    // gl_FragColor = lightValue;\n}\n"},{}],3:[function(e,n,t){"use strict";function i(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(n,t,i){return t&&e(n.prototype,t),i&&e(n,i),n}}(),o=e("./light.frag"),a=e("./blur.frag"),s=t.LightSystem=function(){function e(n,t,r){var s=this;i(this,e),this.w=n||256,this.h=t||256,this.lightTexture=game.add.renderTexture(this.w,this.h,"lightTexture"),this.lightImage=game.add.image(1048576,1048576),this.lightImage.width=this.w,this.lightImage.height=this.h,this.lightImage.smoothed=!0,this.scaleFactor=new Phaser.Point(window.innerWidth/this.w,window.innerHeight/this.h),this.renderedImage=game.add.image(0,window.innerHeight,this.lightTexture),this.renderedImage.width=window.innerWidth,this.renderedImage.height=window.innerHeight,this.renderedImage.fixedToCamera=!0,this.renderedImage.scale.y*=-1,this.renderedImage.smoothed=!0,this.lightFilterUniforms={sizePx:{type:"2fv",value:new Float32Array([window.innerWidth,window.innerHeight])},scaleFactor:{type:"2fv",value:new Float32Array([this.scaleFactor.x,this.scaleFactor.y])},sources:{type:"4fv",value:new Float32Array([])},sourcesCount:{type:"1i",value:0},faces:{type:"4fv",value:new Float32Array([])},facesCount:{type:"1i",value:0},cameraPos:{type:"2fv",value:new Float32Array([0,0])},debug:{type:"1i",value:!!r}},this.blurFilterUniforms={sizePx:{type:"2fv",value:new Float32Array([window.innerWidth,window.innerHeight])}},this.lightFilter=new Phaser.Filter(game,this.lightFilterUniforms,o),this.lightFilter.setResolution(this.w,this.h),this.blurFilter=new Phaser.Filter(game,this.blurFilterUniforms,a),this.lightImage.filters=[this.lightFilter],this.renderedImage.filters=[this.blurFilter],this.lightSources=[],this.objects=[],console.log("Light shader info:"),window.setTimeout(function(){s.printFilterInfo(s.lightFilter)},0)}return r(e,[{key:"getProgramInfo",value:function(e,n){for(var t={attributes:[],uniforms:[],attributeCount:0,uniformCount:0},i=e.getProgramParameter(n,e.ACTIVE_UNIFORMS),r=e.getProgramParameter(n,e.ACTIVE_ATTRIBUTES),o={35664:"FLOAT_VEC2",35665:"FLOAT_VEC3",35666:"FLOAT_VEC4",35667:"INT_VEC2",35668:"INT_VEC3",35669:"INT_VEC4",35670:"BOOL",35671:"BOOL_VEC2",35672:"BOOL_VEC3",35673:"BOOL_VEC4",35674:"FLOAT_MAT2",35675:"FLOAT_MAT3",35676:"FLOAT_MAT4",35678:"SAMPLER_2D",35680:"SAMPLER_CUBE",5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5124:"INT",5125:"UNSIGNED_INT",5126:"FLOAT"},a=0;a<i;a++){var s=e.getActiveUniform(n,a);s.typeName=o[s.type],t.uniforms.push(s),t.uniformCount+=s.size}for(var a=0;a<r;a++){var l=e.getActiveAttrib(n,a);l.typeName=o[l.type],t.attributes.push(l),t.attributeCount+=l.size}return t}},{key:"printFilterInfo",value:function(e){var n=e.shaders[0],t=this.getProgramInfo(n.gl,n.program);console.table(t.attributes),console.table(t.uniforms)}},{key:"addLightSource",value:function(e){this.lightSources.push(e)}},{key:"removeLightSource",value:function(e){var n=this.lightSources.indexOf(e);this.lightSources.splice(n,1)}},{key:"addObject",value:function(e){this.objects.push(e)}},{key:"removeObject",value:function(e){var n=this.objects.indexOf(e);this.objects.splice(n,1)}},{key:"removeAll",value:function(){this.lightSources=[],this.objects=[]}},{key:"updateLightSourcesUniforms",value:function(){var e=this;this.lightFilterUniforms.sources.value=new Float32Array(this.lightSources.reduce(function(n,t){return n.concat(t.getArray(e.scaleFactor))},[])),this.lightFilterUniforms.sourcesCount.value=this.lightSources.length}},{key:"updateFacesUniforms",value:function(){var e=this;this.lightFilterUniforms.faces.value=new Float32Array(this.objects.reduce(function(n,t){return n.concat(t.getArray(e.scaleFactor))},[])),this.lightFilterUniforms.facesCount.value=this.lightFilterUniforms.faces.value.length/4}},{key:"updateUniforms",value:function(){this.updateLightSourcesUniforms(),this.updateFacesUniforms()}},{key:"updateCameraPos",value:function(e){this.lightFilterUniforms.cameraPos.value=new Float32Array([e.x,e.y])}},{key:"setDebug",value:function(e){this.lightFilterUniforms.debug.value=!!e}},{key:"update",value:function(){this.lightFilter.update(),this.blurFilter.update(),this.lightTexture.renderXY(this.lightImage,0,0,!0)}},{key:"destroy",value:function(){this.lightFilter.destroy(),this.blurFilter.destroy(),this.image.destroy()}}]),e}(),l=t.LightSource=function(){function e(n,t,r,o,a,s){i(this,e),this.position=n,this.radius=t,this.intensity=r,this.color=o,this._angleStart=a||0,this._angleEnd=s||0,this.setRotation(0)}return r(e,[{key:"getArray",value:function(e){return[this.position.x,this.position.y,this.radius,this.intensity,this.color[0],this.color[1],this.color[2],this.color[3],this.angleStart,this.angleEnd,0,0]}},{key:"setRotation",value:function(e){0==this._angleStart&&0==this._andleEnd||(this.rotation=e,this.angleStart=(this._angleStart+this.rotation)%(2*Math.PI),this.angleEnd=(this._angleEnd+this.rotation)%(2*Math.PI),this.angleStart<0&&(this.angleStart+=2*Math.PI),this.angleEnd<0&&(this.angleEnd+=2*Math.PI))}}]),e}(),c=t.LightedObject=function(){function e(n){i(this,e),this.points=n}return r(e,[{key:"getArray",value:function(e){var n=this,t=[],i=this.points;return i.length>2&&(i=i.concat([i[0]])),i.forEach(function(e,i){i&&t.push.apply(t,[n.points[i-1].x,n.points[i-1].y,e.x,e.y])}),t}},{key:"getFacesCount",value:function(){return this.points.length<3?1:this.points.length}}]),e}();window.LightSystem=s,window.LightSource=l,window.LightedObject=c},{"./blur.frag":1,"./light.frag":2}]},{},[3]);